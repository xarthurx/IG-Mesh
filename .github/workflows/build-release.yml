name: Build and Release

on:
  push:
    branches: [main,macos-fix]
    tags:
      - "v*"

jobs:
  build-cpp:
    strategy:
      matrix:
        os: [windows-latest, macos-latest]
        include:
          - os: windows-latest
            output-ext: ".dll"
            output-path: "build/GeoSharPlusCPP.dll" # use ninja on github actions
            triplet: "x64-windows"
            configure-preset: "windows-default"
            build-preset: "windows-release"
          - os: macos-latest
            output-ext: ".dylib"
            output-path: "build/libGeoSharPlusCPP.dylib"
            triplet: "arm64-osx"
            configure-preset: "macos-default"
            build-preset: "macos-release"
    runs-on: ${{ matrix.os }}
    env:
      CPP_Project: GeoSharPlusCPP
      CPP_PREBUILD_DIR: cppPrebuild

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # Generate cache key based on C++ source files
      - name: Generate C++ Cache Key
        id: cpp-cache-key
        shell: bash
        run: |
          # Create hash of all C++ source and header files
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            cpp_hash=$(find ${{ env.CPP_Project }}/src ${{ env.CPP_Project }}/include ${{ env.CPP_Project }}/CMakeLists.txt -type f \( -name "*.cpp" -o -name "*.h" -o -name "*.hpp" -o -name "CMakeLists.txt" \) -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)
          else
            cpp_hash=$(find ${{ env.CPP_Project }}/src ${{ env.CPP_Project }}/include ${{ env.CPP_Project }}/CMakeLists.txt -type f \( -name "*.cpp" -o -name "*.h" -o -name "*.hpp" -o -name "CMakeLists.txt" \) -exec shasum -a 256 {} \; | sort | shasum -a 256 | cut -d' ' -f1)
          fi
          echo "hash=$cpp_hash" >> $GITHUB_OUTPUT
          echo "C++ source hash: $cpp_hash"

      # Try to restore C++ build from cache
      - name: Cache C++ Build Artifacts
        id: cache-cpp
        uses: actions/cache@v3
        with:
          path: |
            ${{ env.CPP_Project }}/build
            ${{ env.CPP_PREBUILD_DIR }}
          key: cpp-build-${{ matrix.os }}-${{ steps.cpp-cache-key.outputs.hash }}
          restore-keys: |
            cpp-build-${{ matrix.os }}-

      # Setup vcpkg (required by the C++ project)
      - name: Setup CMake
        if: steps.cache-cpp.outputs.cache-hit != 'true'
        uses: lukka/get-cmake@latest

      - name: Setup vcpkg
        if: steps.cache-cpp.outputs.cache-hit != 'true'
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgGitCommitId: ce613c41372b23b1f51333815feb3edd87ef8a8b # 2025-04-09 version

      # Configure and build using CMake (only if cache miss)
      - name: Configure and Build with CMake
        if: steps.cache-cpp.outputs.cache-hit != 'true'
        uses: lukka/run-cmake@v10
        with:
          cmakeListsTxtPath: "${{ github.workspace }}/${{ env.CPP_Project }}/CMakeLists.txt"
          configurePreset: ${{ matrix.configure-preset }}
          buildPreset: ${{ matrix.build-preset }}

      # Create platform-specific directory in cppPrebuild
      - name: Create platform directory
        if: steps.cache-cpp.outputs.cache-hit != 'true'
        shell: bash
        run: |
          mkdir -p ${{ env.CPP_PREBUILD_DIR }}

      # Copy the built libraries to the platform-specific directory (only if cache miss)
      - name: Copy C++ artifacts (Windows)
        if: steps.cache-cpp.outputs.cache-hit != 'true' && matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          Write-Host ""
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host "  COPYING C++ ARTIFACTS (WINDOWS)" -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host ""
          
          $found = $false
          
          # Check the specified output path first
          if (Test-Path "${{ github.workspace }}/${{ env.CPP_Project }}/${{ matrix.output-path }}") {
            Copy-Item "${{ github.workspace }}/${{ env.CPP_Project }}/${{ matrix.output-path }}" -Destination "${{ env.CPP_PREBUILD_DIR }}/GeoSharPlusCPP${{ matrix.output-ext }}"
            Write-Host "[SUCCESS] Copied from ${{ matrix.output-path }}" -ForegroundColor Green
            $found = $true
          }
          # Check build/Release subdirectory
          elseif (Test-Path "${{ github.workspace }}/${{ env.CPP_Project }}/build/Release/GeoSharPlusCPP.dll") {
            Copy-Item "${{ github.workspace }}/${{ env.CPP_Project }}/build/Release/GeoSharPlusCPP.dll" -Destination "${{ env.CPP_PREBUILD_DIR }}/GeoSharPlusCPP${{ matrix.output-ext }}"
            Write-Host "[SUCCESS] Copied from build/Release/" -ForegroundColor Green
            $found = $true
          }
          
          if (-not $found) {
            Write-Host "[ERROR] Built library not found at expected locations" -ForegroundColor Red
            Write-Host ""
            Write-Host "Searching for DLL in build directory..." -ForegroundColor Yellow
            Get-ChildItem -Path "${{ github.workspace }}/${{ env.CPP_Project }}/build" -Recurse -Filter "*.dll" | ForEach-Object { 
              Write-Host "  - $($_.FullName)" -ForegroundColor Gray
            }
            exit 1
          }

      - name: Copy C++ artifacts (MacOS)
        if: steps.cache-cpp.outputs.cache-hit != 'true' && matrix.os == 'macos-latest'
        shell: bash
        run: |
          echo ""
          echo "========================================"
          echo "  COPYING C++ ARTIFACTS (MACOS)"
          echo "========================================"
          echo ""
          
          found=false
          
          # Check the specified output path first
          if [ -f "${{ github.workspace }}/${{ env.CPP_Project }}/${{ matrix.output-path }}" ]; then
            cp ${{ github.workspace }}/${{ env.CPP_Project }}/${{ matrix.output-path }} ${{ env.CPP_PREBUILD_DIR }}/libGeoSharPlusCPP${{ matrix.output-ext }}
            echo "[SUCCESS] Copied from ${{ matrix.output-path }}"
            found=true
          # Check build/Release subdirectory
          elif [ -f "${{ github.workspace }}/${{ env.CPP_Project }}/build/Release/libGeoSharPlusCPP.dylib" ]; then
            cp ${{ github.workspace }}/${{ env.CPP_Project }}/build/Release/libGeoSharPlusCPP.dylib ${{ env.CPP_PREBUILD_DIR }}/libGeoSharPlusCPP${{ matrix.output-ext }}
            echo "[SUCCESS] Copied from build/Release/"
            found=true
          fi
          
          if [ "$found" = false ]; then
            echo "[ERROR] Built library not found at expected locations"
            echo ""
            echo "Searching for dylib files..."
            find ${{ github.workspace }}/${{ env.CPP_Project }}/build -name "*.dylib" -type f
            exit 1
          fi

      # Report cache status
      - name: Report Cache Status
        shell: bash
        run: |
          if [ "${{ steps.cache-cpp.outputs.cache-hit }}" = "true" ]; then
            echo ""
            echo "========================================"
            echo "  ✓ USING CACHED C++ BUILD"
            echo "========================================"
            echo ""
            echo "Cache key: cpp-build-${{ matrix.os }}-${{ steps.cpp-cache-key.outputs.hash }}"
            echo "Build was restored from cache - no compilation needed!"
          else
            echo ""
            echo "========================================"
            echo "  ⚡ FRESH C++ BUILD COMPLETED"
            echo "========================================"
            echo ""
            echo "Cache key: cpp-build-${{ matrix.os }}-${{ steps.cpp-cache-key.outputs.hash }}"
            echo "Build will be cached for future runs"
          fi

      # Upload C++ artifacts
      - name: Upload C++ artifacts
        uses: actions/upload-artifact@v4
        with:
          name: cpp-libs-${{ matrix.os }} # Dynamic name based on OS
          path: ${{ env.CPP_PREBUILD_DIR }}

  # Build C# project
  build-csharp:
    needs: build-cpp
    runs-on: windows-latest
    env:
      Solution_Name: igMesh.slnx
      CSProj_Path: ./igm/igm.csproj
      Configuration: Release
      ARTIFACTS_DIR: artifacts/release
      CPP_PREBUILD_DIR: cppPrebuild
      YAK_TOKEN: ${{ secrets.YAK_TOKEN }}

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Add MSBuild to PATH
        uses: microsoft/setup-msbuild@v2

      - name: Setup NuGet
        uses: NuGet/setup-nuget@v2

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: 8.0.x

      - name: Restore NuGet packages
        run: dotnet restore ${{ env.CSProj_Path }}

      # Build C# Project first - does NOT rebuild C++
      - name: Build C# Project
        run: |
          $solutionPath = "${{ github.workspace }}\${{ env.Solution_Name }}"
          msbuild ${{ env.CSProj_Path }} `
            /p:Configuration=${{ env.Configuration }} `
            /p:Platform=AnyCPU `
            /p:SolutionDir="${{ github.workspace }}\" `
            /p:SolutionPath="$solutionPath"

      # Download C++ artifacts and copy directly to output directories
      - name: Download Windows C++ libs
        uses: actions/download-artifact@v4
        with:
          name: cpp-libs-windows-latest
          path: ${{ env.CPP_PREBUILD_DIR }}/windows

      - name: Download macOS C++ libs
        uses: actions/download-artifact@v4
        with:
          name: cpp-libs-macos-latest
          path: ${{ env.CPP_PREBUILD_DIR }}/macos

      - name: Copy C++ libraries to output directories
        shell: pwsh
        run: |
          Write-Host ""
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host "  COPYING C++ LIBS TO OUTPUT" -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host ""

          # Find all target framework directories in bin/Release/
          $targetDirs = Get-ChildItem -Path "${{ github.workspace }}\bin\Release" -Directory

          foreach ($targetDir in $targetDirs) {
            Write-Host "[TARGET] $($targetDir.Name)" -ForegroundColor Yellow
            
            # Copy Windows DLL
            $windowsDll = "${{ env.CPP_PREBUILD_DIR }}\windows\GeoSharPlusCPP.dll"
            if (Test-Path $windowsDll) {
              Copy-Item -Path $windowsDll -Destination $targetDir.FullName -Force
              Write-Host "  ✓ Copied GeoSharPlusCPP.dll" -ForegroundColor Green
            } else {
              Write-Host "  [WARNING] Windows DLL not found at $windowsDll" -ForegroundColor Yellow
            }
            
            # Copy macOS dylib
            $macosDylib = "${{ env.CPP_PREBUILD_DIR }}\macos\libGeoSharPlusCPP.dylib"
            if (Test-Path $macosDylib) {
              Copy-Item -Path $macosDylib -Destination $targetDir.FullName -Force
              Write-Host "  ✓ Copied libGeoSharPlusCPP.dylib" -ForegroundColor Green
            } else {
              Write-Host "  [WARNING] macOS dylib not found at $macosDylib" -ForegroundColor Yellow
            }
          }

          # List contents of bin/Release directories to verify
          Write-Host ""
          Write-Host "[VERIFICATION] Contents of bin/Release directories" -ForegroundColor Green
          Get-ChildItem -Path "${{ github.workspace }}\bin\Release" -Recurse -File | 
            Where-Object { $_.Extension -in '.dll', '.gha', '.dylib' } | 
            ForEach-Object { 
              Write-Host "  - $($_.FullName.Replace('${{ github.workspace }}\', ''))" -ForegroundColor Gray
            }

      - name: Prepare Artifacts
        shell: pwsh
        run: |
          Write-Host ""
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host "  PREPARING RELEASE ARTIFACTS" -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host ""
          
          # Create artifacts directory
          New-Item -ItemType Directory -Path ${{ env.ARTIFACTS_DIR }} -Force | Out-Null
          Write-Host "[CREATED] Artifacts directory" -ForegroundColor Green

          # Download Yak.exe to the bin/Release directory
          Write-Host ""
          Write-Host "[DOWNLOADING] Yak.exe..." -ForegroundColor Yellow
          
          $binReleasePath = "${{ github.workspace }}\bin\Release"
          $yakExePath = Join-Path $binReleasePath "yak.exe"
          
          try {
            Invoke-WebRequest -Uri "https://files.mcneel.com/yak/tools/latest/yak.exe" -OutFile $yakExePath
            Write-Host "[SUCCESS] Downloaded yak.exe to bin\Release" -ForegroundColor Green
          } catch {
            Write-Host "[ERROR] Failed to download yak.exe: $_" -ForegroundColor Red
            exit 1
          }

          # Find the target framework directory (e.g., net8.0-windows)
          $targetFrameworkDir = Get-ChildItem -Path $binReleasePath -Directory | Select-Object -First 1
          
          if (-not $targetFrameworkDir) {
            Write-Host "[ERROR] No target framework directory found in bin\Release" -ForegroundColor Red
            exit 1
          }
          
          Write-Host ""
          Write-Host "[TARGET FRAMEWORK] $($targetFrameworkDir.Name)" -ForegroundColor Yellow
          
          # Change to target framework directory
          Push-Location $targetFrameworkDir.FullName
          
          # Verify all required files are present
          Write-Host ""
          Write-Host "[VERIFICATION] Checking for required files..." -ForegroundColor Yellow
          $requiredFiles = @("*.gha", "GeoSharPlusCPP.dll", "libGeoSharPlusCPP.dylib")
          foreach ($pattern in $requiredFiles) {
            $files = Get-ChildItem -Filter $pattern
            if ($files.Count -gt 0) {
              Write-Host "  ✓ Found: $pattern" -ForegroundColor Green
            } else {
              Write-Host "  [WARNING] Not found: $pattern" -ForegroundColor Yellow
            }
          }

          # Generate manifest using yak spec
          Write-Host ""
          Write-Host "[GENERATING] Manifest..." -ForegroundColor Yellow
          
          try {
            & "..\yak.exe" spec
            if ($LASTEXITCODE -eq 0) {
              Write-Host "[SUCCESS] Generated manifest.yml" -ForegroundColor Green
            } else {
              Write-Host "[ERROR] Failed to generate manifest" -ForegroundColor Red
              Pop-Location
              exit 1
            }
          } catch {
            Write-Host "[ERROR] Exception during manifest generation: $_" -ForegroundColor Red
            Pop-Location
            exit 1
          }

          # Copy plugin icon if it exists
          $iconPath = "${{ github.workspace }}\scripts\pluginIcon.png"
          if (Test-Path $iconPath) {
            Copy-Item -Path $iconPath -Destination "." -Force
            Write-Host "[COPIED] Plugin icon" -ForegroundColor Green
          } else {
            Write-Host "[WARNING] Plugin icon not found at: $iconPath" -ForegroundColor Yellow
          }

          # Append additional manifest entries
          Write-Host ""
          Write-Host "[UPDATING] Manifest metadata..." -ForegroundColor Yellow
          if (Test-Path $iconPath) {
            Add-Content manifest.yml "`nicon: pluginIcon.png"
          }
          Add-Content manifest.yml "`nkeywords: `n - mesh `n - geometry `n - high-performance"
          Write-Host "[SUCCESS] Added metadata" -ForegroundColor Green

          # Display manifest content
          Write-Host ""
          Write-Host "[MANIFEST CONTENT]" -ForegroundColor Green
          Write-Host "--------------------------------------" -ForegroundColor Gray
          Get-Content manifest.yml | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }
          Write-Host "--------------------------------------" -ForegroundColor Gray

          # Build the Yak package
          Write-Host ""
          Write-Host "[BUILDING] Yak package..." -ForegroundColor Yellow
          
          try {
            & "..\yak.exe" build
            if ($LASTEXITCODE -eq 0) {
              Write-Host "[SUCCESS] Package built successfully" -ForegroundColor Green
              
              # Display generated .yak file
              $yakFiles = Get-ChildItem -Path "." -Filter "*.yak"
              if ($yakFiles.Count -gt 0) {
                Write-Host ""
                Write-Host "[GENERATED PACKAGE]" -ForegroundColor Green
                foreach ($yakFile in $yakFiles) {
                  Write-Host "  - $($yakFile.Name) ($('{0:N2}' -f ($yakFile.Length / 1MB)) MB)" -ForegroundColor Yellow
                  
                  # Copy .yak file to artifacts (use absolute path)
                  $artifactsPath = "${{ github.workspace }}\${{ env.ARTIFACTS_DIR }}"
                  Copy-Item -Path $yakFile.FullName -Destination $artifactsPath -Force
                  Write-Host "  - Copied to artifacts directory" -ForegroundColor Green
                }
              }
            } else {
              Write-Host "[ERROR] Failed to build package" -ForegroundColor Red
              Pop-Location
              exit 1
            }
          } catch {
            Write-Host "[ERROR] Exception during package build: $_" -ForegroundColor Red
            Pop-Location
            exit 1
          }

          Pop-Location

          # Copy entire bin directory to artifacts for reference
          Write-Host ""
          Write-Host "[COPYING] Bin directory to artifacts..." -ForegroundColor Yellow
          Copy-Item -Path "${{ github.workspace }}\bin" -Destination "${{ github.workspace }}\${{ env.ARTIFACTS_DIR }}" -Recurse -Force
          Write-Host "[SUCCESS] Copied bin directory" -ForegroundColor Green

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-packages
          path: |
            ${{ env.ARTIFACTS_DIR }}/*.yak

      # Push to Yak server using the downloaded yak.exe
      - name: Push to Yak Server
        if: github.ref_type == 'tag' && env.YAK_TOKEN != ''
        shell: pwsh
        run: |
          Write-Host ""
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host "  PUSHING TO YAK SERVER" -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host ""

          # Find the .yak file
          $yakFile = Get-ChildItem -Path "${{ env.ARTIFACTS_DIR }}" -Filter "*.yak" | Select-Object -First 1

          if (-not $yakFile) {
            Write-Host "[ERROR] No .yak file found in ${{ env.ARTIFACTS_DIR }}" -ForegroundColor Red
            exit 1
          }
          
          Write-Host "[PACKAGE] $($yakFile.Name) ($('{0:N2}' -f ($yakFile.Length / 1MB)) MB)" -ForegroundColor Yellow

          # Use the yak.exe downloaded to bin/Release
          $yakExe = "${{ github.workspace }}\bin\Release\yak.exe"
          
          if (-not (Test-Path $yakExe)) {
            Write-Host "[ERROR] yak.exe not found at $yakExe" -ForegroundColor Red
            exit 1
          }
          
          Write-Host "[TOOL] Using yak.exe from: $yakExe" -ForegroundColor Gray
          Write-Host ""

          # Retry logic for push (up to 3 attempts)
          $maxRetries = 3
          $retryCount = 0
          $success = $false
          
          while (-not $success -and $retryCount -lt $maxRetries) {
            $retryCount++
            Write-Host "[ATTEMPT] $retryCount of $maxRetries..." -ForegroundColor Yellow
            
            & $yakExe push $yakFile.FullName
            
            if ($LASTEXITCODE -eq 0) {
              Write-Host ""
              Write-Host "[SUCCESS] ✓ Pushed $($yakFile.Name) to Yak server" -ForegroundColor Green
              $success = $true
            } else {
              Write-Host "[FAILED] Push failed with exit code: $LASTEXITCODE" -ForegroundColor Red
              if ($retryCount -lt $maxRetries) {
                Write-Host "[RETRY] Waiting 30 seconds before next attempt..." -ForegroundColor Yellow
                Start-Sleep -Seconds 30
              }
            }
          }
          
          if (-not $success) {
            Write-Host ""
            Write-Host "[ERROR] Failed to push to Yak server after $maxRetries attempts" -ForegroundColor Red
            exit 1
          }
          
          Write-Host ""
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host "  YAK PUSH COMPLETED" -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host ""

      # Extract tag message for release notes
      - name: Extract Tag Message
        if: github.ref_type == 'tag'
        id: tag_message
        shell: pwsh
        run: |
          Write-Host ""
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host "  EXTRACTING TAG MESSAGE" -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host ""
          
          # Get the tag annotation message
          $tagMessage = git tag -l --format='%(contents)' ${{ github.ref_name }}

          if ([string]::IsNullOrWhiteSpace($tagMessage)) {
            Write-Host "[INFO] No tag annotation found, will use auto-generated notes only" -ForegroundColor Yellow
            echo "has_message=false" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "[TAG MESSAGE]" -ForegroundColor Green
            Write-Host $tagMessage -ForegroundColor Gray
            
            # Escape for JSON/multiline
            $tagMessage = $tagMessage -replace "`r`n", "%0A" -replace "`n", "%0A" -replace '"', '\"'
            echo "has_message=true" >> $env:GITHUB_OUTPUT
            echo "message=$tagMessage" >> $env:GITHUB_OUTPUT
          }

      # Create GitHub Release
      - name: Create Release
        if: github.ref_type == 'tag'
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ env.ARTIFACTS_DIR }}/*.yak
          name: Release ${{ github.ref_name }}
          body: ${{ steps.tag_message.outputs.has_message == 'true' && steps.tag_message.outputs.message || '' }}
          draft: false
          prerelease: false
          generate_release_notes: true
